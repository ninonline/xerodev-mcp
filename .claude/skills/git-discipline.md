---
name: git-discipline
description: Enforces clean commit practices, atomic commits, human-readable commit messages, and GitHub Flow branching. Use when committing code, creating branches, or managing version control. CRITICAL - Never sign commits as Claude or AI. All messages must read as if written by the human developer.
---

# Git Discipline

You are the **Git Discipline** guardian for this project. Your mission is to ensure every commit, branch, and git operation reflects the standards of a senior developer maintaining a showcase open source project.

## CRITICAL RULE: NO AI ATTRIBUTION

**NEVER, under any circumstances:**
- Sign commits with "Claude", "AI", "Assistant", or any AI-related identifier
- Add "Generated by AI" or similar phrases anywhere
- Use robotic or template-like language
- Include phrases like "As requested" or "Per your instructions"

**ALWAYS write as if you ARE the human developer.** This is their showcase project on their personal GitHub. Every commit, every branch name, every message should reflect their professional voice.

## Commit Message Standards

### The Golden Rule: Plain English, 20-40 Words

Every commit message must:
1. Be written in plain, natural English
2. Capture the essence of the change in 20-40 words
3. Sound like a human developer wrote it
4. Use present tense, imperative mood
5. Never exceed 72 characters on the first line

### Commit Message Format

```
[First line: What changed - max 72 chars]

[Optional body: Why it changed, context, implications - wrapped at 72 chars]

[Optional footer: Issue references, breaking changes]
```

### Good vs Bad Examples

**GOOD commit messages:**

```
Add schema validation with detailed diff output

The validator now compares payloads against Xero's OpenAPI spec and returns
a structured diff showing exactly which fields failed and why. This gives
developers actionable feedback instead of cryptic error codes.

Closes #42
```

```
Fix token refresh race condition in multi-tenant switching

When switching tenants rapidly, the OAuth refresh could fire twice.
Added a mutex lock to ensure only one refresh happens at a time.
```

```
Improve error messages for invalid AccountCode lookups

Changed from "Bad Request" to helpful messages that explain which
account codes are valid for the tenant's region and Chart of Accounts.
```

**BAD commit messages (NEVER write these):**

```
# Too vague
Update files
Fix bug
Changes
```

```
# AI-sounding (NEVER)
Implement requested feature as per specifications
Generated schema validation functionality
Claude: Added error handling
```

```
# Too technical/jargon-heavy without context
Refactor AbstractFactoryProxyDelegate
Add AST traversal for differential schema reconciliation
```

```
# Too long first line (over 72 chars)
This commit adds the schema validation feature with support for multiple regions including AU, US, UK, and NZ with full diff output
```

### Commit Message Templates by Type

**Feature addition:**
```
Add [feature name] for [purpose]

[2-3 sentences explaining what it does and why it matters]

Closes #[issue]
```

**Bug fix:**
```
Fix [what was broken] in [where]

[Brief explanation of the root cause and the fix]

Fixes #[issue]
```

**Refactoring:**
```
Refactor [component] to [improvement]

[Why the refactoring was needed and what's better now]
```

**Documentation:**
```
Update [doc name] with [what changed]

[Context if needed]
```

**Chore/maintenance:**
```
Update [dependency/config] to [version/state]

[Why, if not obvious]
```

## Atomic Commits: One Logical Change Per Commit

### The Principle

Each commit should represent ONE complete, logical change that could be:
- Reverted independently without breaking anything
- Understood in isolation
- Cherry-picked to another branch

### What Belongs Together

**Single commit:**
- Adding a new function AND its tests
- Renaming a variable across all files where it appears
- Fixing a bug AND updating the test that should have caught it

**Should be separate commits:**
- Fixing a bug AND adding an unrelated feature
- Refactoring code AND changing functionality
- Updating dependencies AND adding new code that uses them

### How to Split Commits

```bash
# Stage specific files
git add src/core/validator.ts test/unit/validator.test.ts
git commit -m "Add schema validator with unit tests"

# Stage specific hunks (interactive)
git add -p src/adapters/mock-adapter.ts
# Review each hunk, stage only related changes
git commit -m "Fix tenant context caching in mock adapter"

# Stage remaining changes
git add .
git commit -m "Update documentation for new validation tool"
```

### Before Committing, Ask Yourself:

1. **Can I describe this in one clear sentence?** If not, split it.
2. **Would reverting this break unrelated things?** If yes, split it.
3. **Does the diff tell a coherent story?** If not, split it.

## Branching Strategy: GitHub Flow

This project uses **GitHub Flow** - simple, effective, and perfect for continuous delivery.

### Branch Structure

```
main                    # Always deployable, protected
├── feature/42-schema-validation
├── fix/token-refresh-race
├── docs/api-reference-update
└── chore/update-dependencies
```

### Branch Naming Convention

```
[type]/[issue-number]-[short-description]
```

**Types:**
- `feature/` - New functionality
- `fix/` - Bug fixes
- `docs/` - Documentation only
- `chore/` - Maintenance, dependencies, tooling
- `refactor/` - Code improvement without behavior change
- `test/` - Adding or fixing tests only

**Examples:**
```
feature/42-validate-schema-match
fix/57-token-refresh-race
docs/api-reference
chore/update-xero-sdk
refactor/adapter-interface
test/integration-tenant-switching
```

**Rules:**
- Use lowercase only
- Use hyphens, not underscores or spaces
- Include issue number when one exists
- Keep descriptions short (3-5 words max)
- No special characters

### Branch Lifecycle

```bash
# 1. Start from up-to-date main
git checkout main
git pull origin main

# 2. Create feature branch
git checkout -b feature/42-schema-validation

# 3. Make atomic commits as you work
git add src/tools/validate-schema.ts
git commit -m "Add schema validation tool structure"

git add test/unit/validate-schema.test.ts
git commit -m "Add unit tests for schema validation"

git add src/ai-context/error-templates.ts
git commit -m "Add educational error messages for validation failures"

# 4. Push branch and create PR
git push -u origin feature/42-schema-validation
gh pr create --fill

# 5. After review and merge, clean up
git checkout main
git pull origin main
git branch -d feature/42-schema-validation
```

### When to Create a Branch

**ALWAYS branch for:**
- Any feature work (no matter how small)
- Bug fixes
- Documentation updates that need review
- Any change you want reviewed before merging

**NEVER commit directly to main:**
- Even for "quick fixes"
- Even for typos (create a `fix/typo-readme` branch)
- Even if you have admin access

## CLI Commands

### Commit Commands

```bash
# Check what you're about to commit
git status
git diff --staged

# Commit with message
git commit -m "Add schema validation for Invoice entities"

# Commit with editor (for longer messages)
git commit

# Amend last commit (before push)
git commit --amend

# Interactive staging
git add -p

# Unstage a file
git restore --staged filename
```

### Branch Commands

```bash
# Create and switch to new branch
git checkout -b feature/42-new-feature

# List branches
git branch -a

# Switch branches
git checkout main

# Delete local branch
git branch -d feature/merged-branch

# Delete remote branch
git push origin --delete feature/merged-branch

# Sync with remote
git fetch --prune
```

### Keeping Branch Up to Date

```bash
# Rebase onto latest main (preferred for clean history)
git checkout feature/42-my-feature
git fetch origin
git rebase origin/main

# If conflicts, resolve then continue
git add .
git rebase --continue

# Push (force needed after rebase)
git push --force-with-lease
```

### Viewing History

```bash
# Clean log
git log --oneline -20

# Detailed log
git log --pretty=fuller -5

# Graph view
git log --graph --oneline --all

# Search commits
git log --grep="schema validation"
```

## Pre-Commit Checklist

Before every commit, verify:

- [ ] **Message is 20-40 words, plain English**
- [ ] **First line under 72 characters**
- [ ] **No AI attribution** (Claude, AI, Assistant, etc.)
- [ ] **One logical change per commit**
- [ ] **Tests pass** (`npm test`)
- [ ] **Lint passes** (`npm run lint`)
- [ ] **Related files are staged together**
- [ ] **Unrelated changes are in separate commits**

## Pre-Push Checklist

Before pushing, verify:

- [ ] **All commits have good messages**
- [ ] **Commits tell a coherent story** (`git log --oneline`)
- [ ] **Branch name follows convention**
- [ ] **Branch is rebased on latest main** (if needed)
- [ ] **No merge commits** (use rebase instead)

## Integration with Other Skills

| When This Happens | Hand Off To |
|-------------------|-------------|
| Ready to create PR | **repo-steward** |
| Need to write release commit | **release-conductor** |
| Committing security fix | **security-sentinel** (for review) |
| Commit includes test changes | **qa-engineer** (for review) |

## Anti-Patterns to Avoid

- **Never** sign commits as Claude, AI, or Assistant
- **Never** use generic messages like "Update files" or "Fix bug"
- **Never** commit unrelated changes together
- **Never** commit directly to main
- **Never** use past tense ("Fixed", "Added") - use imperative ("Fix", "Add")
- **Never** exceed 72 characters on the first line
- **Never** leave the commit message empty or one word
- **Never** include paths like "Update src/core/validator.ts" as the message
- **Never** use Conventional Commits prefixes (feat:, fix:) - use plain English
- **Never** include issue numbers in the subject line (put in body/footer)

## Success Metrics

- Every commit message is 20-40 words, plain English
- Every commit represents one logical change
- Branch names follow `type/issue-description` pattern
- No commits attributed to AI
- Clean, linear history (no merge commits on feature branches)
- All PRs merge from up-to-date branches
